<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/de/wutzuket/create_overdrive/blocks/FusionReactorInput/FusionReactorInputBlock.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/de/wutzuket/create_overdrive/blocks/FusionReactorInput/FusionReactorInputBlock.java" />
              <option name="originalContent" value="package de.wutzuket.create_overdrive.blocks.FusionReactorInput;&#10;&#10;import com.mojang.serialization.MapCodec;&#10;import com.simibubi.create.content.equipment.wrench.IWrenchable;&#10;import com.simibubi.create.foundation.block.IBE;&#10;import de.wutzuket.create_overdrive.index.CPABlockEntities;&#10;import net.minecraft.core.BlockPos;&#10;import net.minecraft.world.level.BlockGetter;&#10;import net.minecraft.world.level.block.BaseEntityBlock;&#10;import net.minecraft.world.level.block.RenderShape;&#10;import net.minecraft.world.level.block.entity.BlockEntity;&#10;import net.minecraft.world.level.block.entity.BlockEntityType;&#10;import net.minecraft.world.level.block.state.BlockState;&#10;import net.minecraft.world.phys.shapes.CollisionContext;&#10;import net.minecraft.world.phys.shapes.Shapes;&#10;import net.minecraft.world.phys.shapes.VoxelShape;&#10;&#10;import javax.annotation.Nullable;&#10;&#10;public class FusionReactorInputBlock extends BaseEntityBlock implements IWrenchable, IBE&lt;FusionReactorInputBlockEntity&gt; {&#10;&#10;    public static final MapCodec&lt;FusionReactorInputBlock&gt; CODEC = simpleCodec(FusionReactorInputBlock::new);&#10;&#10;    public FusionReactorInputBlock(Properties properties) {&#10;        super(properties);&#10;    }&#10;&#10;    @Override&#10;    protected MapCodec&lt;? extends BaseEntityBlock&gt; codec() {&#10;        return CODEC;&#10;    }&#10;&#10;    @Override&#10;    public Class&lt;FusionReactorInputBlockEntity&gt; getBlockEntityClass() {&#10;        return FusionReactorInputBlockEntity.class;&#10;    }&#10;&#10;    @Override&#10;    public BlockEntityType&lt;? extends FusionReactorInputBlockEntity&gt; getBlockEntityType() {&#10;        return CPABlockEntities.FUSION_REACTOR_INPUT.get();&#10;    }&#10;&#10;    @Override&#10;    public VoxelShape getShape(BlockState state, BlockGetter world, BlockPos pos, CollisionContext context) {&#10;        return Shapes.block();&#10;    }&#10;&#10;    @Override&#10;    @Nullable&#10;    public BlockEntity newBlockEntity(BlockPos pos, BlockState state) {&#10;        return CPABlockEntities.FUSION_REACTOR_INPUT.create(pos, state);&#10;    }&#10;&#10;    @Override&#10;    public RenderShape getRenderShape(BlockState state) {&#10;        return RenderShape.MODEL;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package de.wutzuket.create_overdrive.blocks.FusionReactorInput;&#10;&#10;// Entfernt: ursprüngliche Implementierung von FusionReactorInputBlock&#10;// Platzhalter gelassen, damit evtl. alte Referenzen nicht sofort Compilerfehler erzeugen.&#10;@Deprecated&#10;public class FusionReactorInputBlock {&#10;    // intentionally removed&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/de/wutzuket/create_overdrive/blocks/FusionReactorInput/FusionReactorInputBlockEntity.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/de/wutzuket/create_overdrive/blocks/FusionReactorInput/FusionReactorInputBlockEntity.java" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/de/wutzuket/create_overdrive/blocks/fusion_reactor/Casing.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/de/wutzuket/create_overdrive/blocks/fusion_reactor/Casing.java" />
              <option name="originalContent" value="package de.wutzuket.create_overdrive.blocks.fusion_reactor;&#10;&#10;import net.minecraft.core.BlockPos;&#10;import net.minecraft.world.item.ItemStack;&#10;import net.minecraft.world.level.BlockGetter;&#10;import net.minecraft.world.level.block.Block;&#10;import net.minecraft.world.level.block.state.BlockBehaviour;&#10;import net.minecraft.world.level.block.state.BlockState;&#10;import net.minecraft.world.level.storage.loot.LootParams;&#10;import net.minecraft.world.phys.shapes.CollisionContext;&#10;import net.minecraft.world.phys.shapes.Shapes;&#10;import net.minecraft.world.phys.shapes.VoxelShape;&#10;import net.minecraft.world.level.Level;&#10;&#10;import java.util.Collections;&#10;import java.util.List;&#10;&#10;public class Casing extends Block {&#10;    public Casing(BlockBehaviour.Properties properties) {&#10;        super(properties);&#10;    }&#10;&#10;    @Override&#10;    public VoxelShape getShape(BlockState state, BlockGetter world, BlockPos pos, CollisionContext context) {&#10;        return Shapes.or(box(0, 0, 0, 16, 16, 16));&#10;    }&#10;&#10;    @Override&#10;    public void onRemove(BlockState state, Level world, BlockPos pos, BlockState newState, boolean isMoving) {&#10;        if (state.getBlock() != newState.getBlock()) {&#10;            super.onRemove(state, world, pos, newState, isMoving);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public List&lt;ItemStack&gt; getDrops(BlockState state, LootParams.Builder builder) {&#10;        List&lt;ItemStack&gt; dropsOriginal = super.getDrops(state, builder);&#10;        if (!dropsOriginal.isEmpty())&#10;            return dropsOriginal;&#10;        return Collections.singletonList(new ItemStack(this, 1));&#10;    }&#10;}" />
              <option name="updatedContent" value="package de.wutzuket.create_overdrive.blocks.fusion_reactor;&#10;&#10;import de.wutzuket.create_overdrive.Main;&#10;import de.wutzuket.create_overdrive.blocks.fusion_reactor.connected_textures.CTBlockStateProperties;&#10;import net.minecraft.core.BlockPos;&#10;import net.minecraft.core.Direction;&#10;import net.minecraft.world.item.ItemStack;&#10;import net.minecraft.world.level.BlockGetter;&#10;import net.minecraft.world.level.Level;&#10;import net.minecraft.world.level.LevelAccessor;&#10;import net.minecraft.world.level.block.Block;&#10;import net.minecraft.world.level.block.state.BlockBehaviour;&#10;import net.minecraft.world.level.block.state.BlockState;&#10;import net.minecraft.world.level.block.state.StateDefinition;&#10;import net.minecraft.world.level.storage.loot.LootParams;&#10;import net.minecraft.world.phys.shapes.CollisionContext;&#10;import net.minecraft.world.phys.shapes.Shapes;&#10;import net.minecraft.world.phys.shapes.VoxelShape;&#10;&#10;import java.util.Collections;&#10;import java.util.List;&#10;&#10;public class Casing extends Block {&#10;    public Casing(BlockBehaviour.Properties properties) {&#10;        super(properties);&#10;    }&#10;&#10;    @Override&#10;    public VoxelShape getShape(BlockState state, BlockGetter world, BlockPos pos, CollisionContext context) {&#10;        return Shapes.or(box(0, 0, 0, 16, 16, 16));&#10;    }&#10;&#10;    @Override&#10;    public void onRemove(BlockState state, Level world, BlockPos pos, BlockState newState, boolean isMoving) {&#10;        if (state.getBlock() != newState.getBlock()) {&#10;            super.onRemove(state, world, pos, newState, isMoving);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public BlockState updateShape(BlockState state, Direction direction, BlockState neighborState, LevelAccessor level,&#10;                                  BlockPos currentPos, BlockPos neighborPos) {&#10;        // Nicht notwendig, das Modell erkennt selbst benachbarte Blöcke&#10;        return super.updateShape(state, direction, neighborState, level, currentPos, neighborPos);&#10;    }&#10;&#10;    @Override&#10;    public List&lt;ItemStack&gt; getDrops(BlockState state, LootParams.Builder builder) {&#10;        List&lt;ItemStack&gt; dropsOriginal = super.getDrops(state, builder);&#10;        if (!dropsOriginal.isEmpty())&#10;            return dropsOriginal;&#10;        return Collections.singletonList(new ItemStack(this, 1));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/de/wutzuket/create_overdrive/blocks/fusion_reactor/connected_textures/CTBakedModel.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/de/wutzuket/create_overdrive/blocks/fusion_reactor/connected_textures/CTBakedModel.java" />
              <option name="updatedContent" value="package de.wutzuket.create_overdrive.blocks.fusion_reactor.connected_textures;&#10;&#10;import com.google.common.collect.ImmutableList;&#10;import com.mojang.blaze3d.vertex.PoseStack;&#10;import de.wutzuket.create_overdrive.Main;&#10;import net.minecraft.client.Minecraft;&#10;import net.minecraft.client.renderer.RenderType;&#10;import net.minecraft.client.renderer.block.model.BakedQuad;&#10;import net.minecraft.client.renderer.block.model.ItemOverrides;&#10;import net.minecraft.client.renderer.block.model.ItemTransforms;&#10;import net.minecraft.client.renderer.texture.TextureAtlasSprite;&#10;import net.minecraft.client.resources.model.BakedModel;&#10;import net.minecraft.core.BlockPos;&#10;import net.minecraft.core.Direction;&#10;import net.minecraft.resources.ResourceLocation;&#10;import net.minecraft.util.RandomSource;&#10;import net.minecraft.world.item.ItemStack;&#10;import net.minecraft.world.level.BlockAndTintGetter;&#10;import net.minecraft.world.level.block.Block;&#10;import net.minecraft.world.level.block.state.BlockState;&#10;import net.neoforged.neoforge.client.ChunkRenderTypeSet;&#10;import net.neoforged.neoforge.client.model.IDynamicBakedModel;&#10;import net.neoforged.neoforge.client.model.data.ModelData;&#10;import net.neoforged.neoforge.client.model.data.ModelProperty;&#10;import org.jetbrains.annotations.NotNull;&#10;import org.jetbrains.annotations.Nullable;&#10;import org.joml.Vector3f;&#10;&#10;import java.util.*;&#10;import java.util.function.Function;&#10;&#10;public class CTBakedModel implements IDynamicBakedModel {&#10;    &#10;    public static final ModelProperty&lt;Boolean[]&gt; CONNECTIONS = new ModelProperty&lt;&gt;();&#10;    private final BakedModel baseModel;&#10;    private final Block block;&#10;    private final ResourceLocation blockId;&#10;    &#10;    public CTBakedModel(BakedModel baseModel, Block block) {&#10;        this.baseModel = baseModel;&#10;        this.block = block;&#10;        this.blockId = block.builtInRegistryHolder().key().location();&#10;    }&#10;&#10;    @Override&#10;    public @NotNull List&lt;BakedQuad&gt; getQuads(@Nullable BlockState state, @Nullable Direction side, @NotNull RandomSource rand, @NotNull ModelData data, @Nullable RenderType renderType) {&#10;        if (state == null || side == null) {&#10;            return baseModel.getQuads(state, side, rand, data, renderType);&#10;        }&#10;&#10;        Boolean[] connections = data.get(CONNECTIONS);&#10;        if (connections == null) {&#10;            return baseModel.getQuads(state, side, rand, data, renderType);&#10;        }&#10;&#10;        // Bestimme den Texturtyp basierend auf den Verbindungen&#10;        SpriteShifter.TextureType textureType = SpriteShifter.getTextureTypeForConnections(&#10;                connections[Direction.NORTH.ordinal()],&#10;                connections[Direction.EAST.ordinal()],&#10;                connections[Direction.SOUTH.ordinal()],&#10;                connections[Direction.WEST.ordinal()]&#10;        );&#10;&#10;        // Hole die verschobene Textur für diesen Typ&#10;        ResourceLocation shiftedTexture = SpriteShifter.getShiftedSprite(blockId, textureType);&#10;        if (shiftedTexture == null) {&#10;            return baseModel.getQuads(state, side, rand, data, renderType);&#10;        }&#10;&#10;        // Erstelle modifizierte Quads mit der verschobenen Textur&#10;        List&lt;BakedQuad&gt; originalQuads = baseModel.getQuads(state, side, rand, data, renderType);&#10;        List&lt;BakedQuad&gt; modifiedQuads = new ArrayList&lt;&gt;();&#10;&#10;        TextureAtlasSprite shiftedSprite = Minecraft.getInstance().getTextureAtlas(&#10;                net.minecraft.client.renderer.texture.TextureAtlas.LOCATION_BLOCKS).apply(shiftedTexture);&#10;&#10;        for (BakedQuad quad : originalQuads) {&#10;            if (quad.getDirection() == side) {&#10;                // Hier würden wir einen neuen Quad mit der verschobenen Textur erstellen&#10;                // Vereinfachte Implementierung - in der Praxis müsste man die UVs anpassen&#10;                modifiedQuads.add(quad); // Hier würde ein neuer Quad mit der verschobenen Textur erstellt werden&#10;            } else {&#10;                modifiedQuads.add(quad);&#10;            }&#10;        }&#10;&#10;        return modifiedQuads;&#10;    }&#10;    &#10;    @Override&#10;    public @NotNull ModelData getModelData(@NotNull BlockAndTintGetter level, @NotNull BlockPos pos, @NotNull BlockState state, @NotNull ModelData modelData) {&#10;        // Prüfe, ob angrenzende Blöcke vom gleichen Typ sind&#10;        Boolean[] connections = new Boolean[6]; // Für alle 6 Richtungen&#10;        &#10;        for (Direction direction : Direction.values()) {&#10;            BlockPos neighborPos = pos.relative(direction);&#10;            BlockState neighborState = level.getBlockState(neighborPos);&#10;            connections[direction.ordinal()] = neighborState.is(block);&#10;        }&#10;        &#10;        return modelData.derive().with(CONNECTIONS, connections).build();&#10;    }&#10;&#10;    @Override&#10;    public @NotNull ChunkRenderTypeSet getRenderTypes(@NotNull BlockState state, @NotNull RandomSource rand, @NotNull ModelData data) {&#10;        return ChunkRenderTypeSet.of(RenderType.solid());&#10;    }&#10;&#10;    @Override&#10;    public boolean useAmbientOcclusion() {&#10;        return baseModel.useAmbientOcclusion();&#10;    }&#10;&#10;    @Override&#10;    public boolean isGui3d() {&#10;        return baseModel.isGui3d();&#10;    }&#10;&#10;    @Override&#10;    public boolean usesBlockLight() {&#10;        return baseModel.usesBlockLight();&#10;    }&#10;&#10;    @Override&#10;    public boolean isCustomRenderer() {&#10;        return false;&#10;    }&#10;&#10;    @Override&#10;    public TextureAtlasSprite getParticleIcon() {&#10;        return baseModel.getParticleIcon();&#10;    }&#10;&#10;    @Override&#10;    public ItemTransforms getTransforms() {&#10;        return baseModel.getTransforms();&#10;    }&#10;&#10;    @Override&#10;    public ItemOverrides getOverrides() {&#10;        return baseModel.getOverrides();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/de/wutzuket/create_overdrive/blocks/fusion_reactor/connected_textures/CTBlockStateProperties.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/de/wutzuket/create_overdrive/blocks/fusion_reactor/connected_textures/CTBlockStateProperties.java" />
              <option name="updatedContent" value="package de.wutzuket.create_overdrive.blocks.fusion_reactor.connected_textures;&#10;&#10;import net.minecraft.world.level.block.state.properties.BooleanProperty;&#10;&#10;public class CTBlockStateProperties {&#10;    // Kann später für zusätzliche Blockstate-Properties verwendet werden&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/de/wutzuket/create_overdrive/blocks/fusion_reactor/connected_textures/CTModelLoader.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/de/wutzuket/create_overdrive/blocks/fusion_reactor/connected_textures/CTModelLoader.java" />
              <option name="updatedContent" value="package de.wutzuket.create_overdrive.blocks.fusion_reactor.connected_textures;&#10;&#10;import com.google.gson.JsonDeserializationContext;&#10;import com.google.gson.JsonObject;&#10;import de.wutzuket.create_overdrive.Main;&#10;import net.minecraft.client.renderer.block.BlockModelShaper;&#10;import net.minecraft.client.resources.model.BakedModel;&#10;import net.minecraft.client.resources.model.ModelBakery;&#10;import net.minecraft.client.resources.model.ModelState;&#10;import net.minecraft.client.resources.model.UnbakedModel;&#10;import net.minecraft.resources.ResourceLocation;&#10;import net.minecraft.world.level.block.Block;&#10;import net.neoforged.neoforge.client.event.ModelEvent;&#10;import net.neoforged.neoforge.client.event.TextureStitchEvent;&#10;import net.neoforged.neoforge.client.model.geometry.IGeometryBakingContext;&#10;import net.neoforged.neoforge.client.model.geometry.IGeometryLoader;&#10;import net.neoforged.neoforge.client.model.geometry.IUnbakedGeometry;&#10;import net.neoforged.neoforge.registries.ForgeRegistries;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import java.util.function.Function;&#10;&#10;public class CTModelLoader {&#10;    &#10;    private static final Map&lt;ResourceLocation, Block&gt; REGISTERED_CT_BLOCKS = new HashMap&lt;&gt;();&#10;    &#10;    /**&#10;     * Registriert einen Block für Connected Textures&#10;     */&#10;    public static void registerCTBlock(Block block) {&#10;        ResourceLocation blockId = ForgeRegistries.BLOCKS.getKey(block);&#10;        if (blockId != null) {&#10;            REGISTERED_CT_BLOCKS.put(blockId, block);&#10;            String path = blockId.getPath();&#10;            SpriteShifter.registerSpriteShifts(path);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Ersetzt die BakedModels für alle registrierten Blöcke&#10;     */&#10;    public static void onModelBakeEvent(ModelEvent.ModifyBakingResult event) {&#10;        Map&lt;ResourceLocation, BakedModel&gt; registry = event.getModels();&#10;        &#10;        for (Map.Entry&lt;ResourceLocation, Block&gt; entry : REGISTERED_CT_BLOCKS.entrySet()) {&#10;            Block block = entry.getValue();&#10;            ResourceLocation blockModelLoc = BlockModelShaper.stateToModelLocation(block.defaultBlockState());&#10;            &#10;            BakedModel originalModel = registry.get(blockModelLoc);&#10;            if (originalModel != null) {&#10;                BakedModel ctModel = new CTBakedModel(originalModel, block);&#10;                registry.put(blockModelLoc, ctModel);&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Texture Stitching Event Handler&#10;     */&#10;    public static void onTextureStitch(TextureStitchEvent.Pre event) {&#10;        if (event.getAtlas().location().equals(net.minecraft.client.renderer.texture.TextureAtlas.LOCATION_BLOCKS)) {&#10;            SpriteShifter.stitchTextures(event);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Für benutzerdefinierte Modelloader (optional)&#10;     */&#10;    public static class CTGeometryLoader implements IGeometryLoader&lt;CTGeometryLoader.CTGeometry&gt; {&#10;        @Override&#10;        public CTGeometry read(JsonObject jsonObject, JsonDeserializationContext deserializationContext) {&#10;            return new CTGeometry();&#10;        }&#10;        &#10;        public static class CTGeometry implements IUnbakedGeometry&lt;CTGeometry&gt; {&#10;            @Override&#10;            public BakedModel bake(IGeometryBakingContext context, ModelBakery bakery, Function&lt;net.minecraft.client.resources.model.Material, TextureAtlasSprite&gt; spriteGetter, ModelState modelState, ItemOverrides overrides, ResourceLocation modelLocation) {&#10;                // Hier würde die eigentliche Modell-Baking-Logik implementiert werden&#10;                // Vereinfacht - würde normalerweise das zugehörige Vanilla-Modell laden und umwandeln&#10;                return null;&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/de/wutzuket/create_overdrive/blocks/fusion_reactor/connected_textures/SpriteShifter.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/de/wutzuket/create_overdrive/blocks/fusion_reactor/connected_textures/SpriteShifter.java" />
              <option name="updatedContent" value="package de.wutzuket.create_overdrive.blocks.fusion_reactor.connected_textures;&#10;&#10;import com.mojang.math.Transformation;&#10;import de.wutzuket.create_overdrive.Main;&#10;import net.minecraft.client.renderer.texture.TextureAtlasSprite;&#10;import net.minecraft.resources.ResourceLocation;&#10;import net.minecraft.world.level.block.state.BlockState;&#10;import net.neoforged.neoforge.client.event.TextureStitchEvent;&#10;import net.neoforged.neoforge.client.textures.ForgeTextureMetadata;&#10;&#10;import javax.annotation.Nullable;&#10;import java.util.EnumMap;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;public class SpriteShifter {&#10;    &#10;    private static final Map&lt;ResourceLocation, Map&lt;TextureType, ResourceLocation&gt;&gt; REGISTRY = new HashMap&lt;&gt;();&#10;    &#10;    public enum TextureType {&#10;        SINGLE,&#10;        HORIZONTAL,&#10;        VERTICAL,&#10;        CROSS,&#10;        TOP_LEFT,&#10;        TOP_RIGHT,&#10;        BOTTOM_LEFT,&#10;        BOTTOM_RIGHT&#10;    }&#10;    &#10;    public static void registerSpriteShifts(String blockPath) {&#10;        ResourceLocation blockId = new ResourceLocation(Main.MODID, blockPath);&#10;        Map&lt;TextureType, ResourceLocation&gt; textureMap = new EnumMap&lt;&gt;(TextureType.class);&#10;        &#10;        // Registriere alle TextureTypes für diesen Block&#10;        for (TextureType type : TextureType.values()) {&#10;            String suffix = type == TextureType.SINGLE ? &quot;&quot; : &quot;_&quot; + type.name().toLowerCase();&#10;            ResourceLocation textureId = new ResourceLocation(Main.MODID, &quot;block/&quot; + blockPath + suffix);&#10;            textureMap.put(type, textureId);&#10;        }&#10;        &#10;        REGISTRY.put(blockId, textureMap);&#10;    }&#10;    &#10;    @Nullable&#10;    public static ResourceLocation getShiftedSprite(ResourceLocation blockId, TextureType type) {&#10;        Map&lt;TextureType, ResourceLocation&gt; shifts = REGISTRY.get(blockId);&#10;        if (shifts == null)&#10;            return null;&#10;        return shifts.get(type);&#10;    }&#10;    &#10;    public static void stitchTextures(TextureStitchEvent.Pre event) {&#10;        for (Map&lt;TextureType, ResourceLocation&gt; textures : REGISTRY.values()) {&#10;            for (ResourceLocation texture : textures.values()) {&#10;                event.addSprite(texture);&#10;            }&#10;        }&#10;    }&#10;    &#10;    public static TextureType getTextureTypeForConnections(boolean north, boolean east, boolean south, boolean west) {&#10;        if (!north &amp;&amp; !east &amp;&amp; !south &amp;&amp; !west)&#10;            return TextureType.SINGLE;&#10;        &#10;        if (north &amp;&amp; south &amp;&amp; !east &amp;&amp; !west)&#10;            return TextureType.VERTICAL;&#10;        &#10;        if (!north &amp;&amp; !south &amp;&amp; east &amp;&amp; west)&#10;            return TextureType.HORIZONTAL;&#10;        &#10;        if (north &amp;&amp; south &amp;&amp; east &amp;&amp; west)&#10;            return TextureType.CROSS;&#10;        &#10;        if (north &amp;&amp; !south &amp;&amp; !east &amp;&amp; west)&#10;            return TextureType.TOP_LEFT;&#10;        &#10;        if (north &amp;&amp; !south &amp;&amp; east &amp;&amp; !west)&#10;            return TextureType.TOP_RIGHT;&#10;        &#10;        if (!north &amp;&amp; south &amp;&amp; !east &amp;&amp; west)&#10;            return TextureType.BOTTOM_LEFT;&#10;        &#10;        if (!north &amp;&amp; south &amp;&amp; east &amp;&amp; !west)&#10;            return TextureType.BOTTOM_RIGHT;&#10;        &#10;        // Fallback für andere Kombinationen&#10;        return TextureType.SINGLE;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/de/wutzuket/create_overdrive/client/ClientSetup.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/de/wutzuket/create_overdrive/client/ClientSetup.java" />
              <option name="updatedContent" value="package de.wutzuket.create_overdrive.client;&#10;&#10;import de.wutzuket.create_overdrive.client.render.FusionReactorCoreRenderer;&#10;import de.wutzuket.create_overdrive.index.CPABlockEntities;&#10;import net.minecraft.client.renderer.blockentity.BlockEntityRenderers;&#10;import net.neoforged.api.distmarker.Dist;&#10;import net.neoforged.bus.api.SubscribeEvent;&#10;import net.neoforged.fml.common.EventBusSubscriber;&#10;import net.neoforged.fml.event.lifecycle.FMLClientSetupEvent;&#10;&#10;@EventBusSubscriber(modid = &quot;create_overdrive&quot;, bus = EventBusSubscriber.Bus.MOD, value = Dist.CLIENT)&#10;public class ClientSetup {&#10;&#10;    @SubscribeEvent&#10;    public static void onClientSetup(FMLClientSetupEvent event) {&#10;        event.enqueueWork(() -&gt; {&#10;            BlockEntityRenderers.register(CPABlockEntities.FUSION_REACTOR_CORE.get(), FusionReactorCoreRenderer::new);&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/de/wutzuket/create_overdrive/client/render/FusionReactorCoreRenderer.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/de/wutzuket/create_overdrive/client/render/FusionReactorCoreRenderer.java" />
              <option name="originalContent" value="package de.wutzuket.create_overdrive.client.render;&#10;&#10;import com.mojang.blaze3d.vertex.PoseStack;&#10;import com.mojang.blaze3d.vertex.VertexConsumer;&#10;import de.wutzuket.create_overdrive.blocks.FusionReactor.FusionReactorCoreBlockEntity;&#10;import de.wutzuket.create_overdrive.index.CPABlocks;&#10;import net.minecraft.client.Minecraft;&#10;import net.minecraft.client.renderer.MultiBufferSource;&#10;import net.minecraft.client.renderer.blockentity.BlockEntityRenderer;&#10;import net.minecraft.client.renderer.blockentity.BlockEntityRendererProvider;&#10;import net.minecraft.client.resources.model.BakedModel;&#10;import net.minecraft.core.BlockPos;&#10;import net.minecraft.world.level.block.state.BlockState;&#10;import net.neoforged.neoforge.client.model.data.ModelData;&#10;&#10;public class FusionReactorCoreRenderer implements BlockEntityRenderer&lt;FusionReactorCoreBlockEntity&gt; {&#10;&#10;    public FusionReactorCoreRenderer(BlockEntityRendererProvider.Context context) {&#10;    }&#10;&#10;    @Override&#10;    public void render(FusionReactorCoreBlockEntity blockEntity, float partialTick, PoseStack poseStack,&#10;                      MultiBufferSource bufferSource, int packedLight, int packedOverlay) {&#10;&#10;        if (blockEntity.getHologramPositions().isEmpty()) {&#10;            return;&#10;        }&#10;&#10;        BlockPos corePos = blockEntity.getBlockPos();&#10;        BlockState hologramBlock = CPABlocks.FUSION_REACTOR_CASING.get().defaultBlockState();&#10;        BakedModel model = Minecraft.getInstance().getBlockRenderer().getBlockModel(hologramBlock);&#10;&#10;        VertexConsumer vertexConsumer = bufferSource.getBuffer(HologramRenderType.HOLOGRAM);&#10;&#10;        for (BlockPos hologramPos : blockEntity.getHologramPositions()) {&#10;            poseStack.pushPose();&#10;&#10;            // Relative Position zum Core berechnen&#10;            BlockPos relativePos = hologramPos.subtract(corePos);&#10;            poseStack.translate(relativePos.getX(), relativePos.getY(), relativePos.getZ());&#10;&#10;            // Hologramm mit reduzierter Transparenz rendern&#10;            Minecraft.getInstance().getBlockRenderer().getModelRenderer().renderModel(&#10;                poseStack.last(),&#10;                vertexConsumer,&#10;                hologramBlock,&#10;                model,&#10;                0.3f, 0.7f, 1.0f, // Bläuliche Farbe für Hologramm-Effekt&#10;                packedLight,&#10;                packedOverlay,&#10;                ModelData.EMPTY,&#10;                HologramRenderType.HOLOGRAM&#10;            );&#10;&#10;            poseStack.popPose();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public int getViewDistance() {&#10;        return 256;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package de.wutzuket.create_overdrive.client.render;&#10;&#10;import com.mojang.blaze3d.vertex.PoseStack;&#10;import com.mojang.blaze3d.vertex.VertexConsumer;&#10;import de.wutzuket.create_overdrive.blocks.FusionReactor.FusionReactorCoreBlockEntity;&#10;import de.wutzuket.create_overdrive.index.CPABlocks;&#10;import net.minecraft.client.Minecraft;&#10;import net.minecraft.client.renderer.MultiBufferSource;&#10;import net.minecraft.client.renderer.block.BlockRenderDispatcher;&#10;import net.minecraft.client.renderer.blockentity.BlockEntityRenderer;&#10;import net.minecraft.client.renderer.blockentity.BlockEntityRendererProvider;&#10;import net.minecraft.core.BlockPos;&#10;import net.minecraft.util.RandomSource;&#10;import net.minecraft.world.level.block.state.BlockState;&#10;import net.neoforged.neoforge.client.model.data.ModelData;&#10;&#10;public class FusionReactorCoreRenderer implements BlockEntityRenderer&lt;FusionReactorCoreBlockEntity&gt; {&#10;&#10;    public FusionReactorCoreRenderer(BlockEntityRendererProvider.Context context) {&#10;    }&#10;&#10;    @Override&#10;    public void render(FusionReactorCoreBlockEntity blockEntity, float partialTick, PoseStack poseStack,&#10;                      MultiBufferSource bufferSource, int packedLight, int packedOverlay) {&#10;        &#10;        if (blockEntity.getLevel() == null || blockEntity.getHologramPositions().isEmpty()) {&#10;            return;&#10;        }&#10;&#10;        BlockPos corePos = blockEntity.getBlockPos();&#10;        BlockState hologramBlock = CPABlocks.FUSION_REACTOR_CASING.get().defaultBlockState();&#10;        &#10;        BlockRenderDispatcher blockRenderer = Minecraft.getInstance().getBlockRenderer();&#10;        VertexConsumer vertexConsumer = bufferSource.getBuffer(HologramRenderType.HOLOGRAM);&#10;&#10;        for (BlockPos hologramPos : blockEntity.getHologramPositions()) {&#10;            poseStack.pushPose();&#10;            &#10;            // Relative Position zum Core berechnen&#10;            BlockPos relativePos = hologramPos.subtract(corePos);&#10;            poseStack.translate(relativePos.getX(), relativePos.getY(), relativePos.getZ());&#10;&#10;            // Verwende eine einfachere Rendering-Methode&#10;            try {&#10;                blockRenderer.renderSingleBlock(&#10;                    hologramBlock,&#10;                    poseStack,&#10;                    bufferSource,&#10;                    packedLight,&#10;                    packedOverlay,&#10;                    ModelData.EMPTY,&#10;                    HologramRenderType.HOLOGRAM&#10;                );&#10;            } catch (Exception e) {&#10;                // Fallback: Verwende Standard-Block-Rendering&#10;                blockRenderer.renderSingleBlock(&#10;                    hologramBlock,&#10;                    poseStack,&#10;                    bufferSource,&#10;                    packedLight,&#10;                    packedOverlay&#10;                );&#10;            }&#10;&#10;            poseStack.popPose();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public int getViewDistance() {&#10;        return 128;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/de/wutzuket/create_overdrive/client/render/FusionReactorRenderer.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/de/wutzuket/create_overdrive/client/render/FusionReactorRenderer.java" />
              <option name="updatedContent" value="package de.wutzuket.create_overdrive.client.render;&#10;&#10;import com.mojang.blaze3d.vertex.PoseStack;&#10;import com.mojang.blaze3d.vertex.VertexConsumer;&#10;import de.wutzuket.create_overdrive.blocks.FusionReactor.FusionReactorCoreBlockEntity;&#10;import de.wutzuket.create_overdrive.index.CPABlocks;&#10;import net.minecraft.client.Minecraft;&#10;import net.minecraft.client.renderer.MultiBufferSource;&#10;import net.minecraft.client.renderer.RenderType;&#10;import net.minecraft.client.renderer.blockentity.BlockEntityRenderer;&#10;import net.minecraft.client.renderer.blockentity.BlockEntityRendererProvider;&#10;import net.minecraft.core.BlockPos;&#10;import net.minecraft.world.level.block.state.BlockState;&#10;import net.minecraftforge.client.model.data.ModelData;&#10;&#10;public class FusionReactorRenderer implements BlockEntityRenderer&lt;FusionReactorCoreBlockEntity&gt; {&#10;&#10;    public FusionReactorRenderer(BlockEntityRendererProvider.Context context) {&#10;    }&#10;&#10;    @Override&#10;    public void render(FusionReactorCoreBlockEntity blockEntity, float partialTick, PoseStack poseStack, MultiBufferSource bufferSource, int packedLight, int packedOverlay) {&#10;        if (!blockEntity.shouldShowHologram()) {&#10;            return;&#10;        }&#10;&#10;        BlockPos corePos = blockEntity.getBlockPos();&#10;        &#10;        // Render Layer 1 (y = -1)&#10;        renderLayer1(corePos, poseStack, bufferSource, packedLight, packedOverlay);&#10;        &#10;        // Render Layer 2 (y = 0)&#10;        renderLayer2(corePos, poseStack, bufferSource, packedLight, packedOverlay);&#10;        &#10;        // Render Layer 3 (y = 1)&#10;        renderLayer3(corePos, poseStack, bufferSource, packedLight, packedOverlay);&#10;    }&#10;&#10;    private void renderLayer1(BlockPos corePos, PoseStack poseStack, MultiBufferSource bufferSource, int packedLight, int packedOverlay) {&#10;        for (int i = -2; i &lt;= 3; i++) {&#10;            renderHologramBlock(corePos.offset(i, -1, 3), poseStack, bufferSource, packedLight, packedOverlay);&#10;            renderHologramBlock(corePos.offset(-i, -1, -3), poseStack, bufferSource, packedLight, packedOverlay);&#10;            renderHologramBlock(corePos.offset(3, -1, -i), poseStack, bufferSource, packedLight, packedOverlay);&#10;            renderHologramBlock(corePos.offset(-3, -1, i), poseStack, bufferSource, packedLight, packedOverlay);&#10;        }&#10;    }&#10;&#10;    private void renderLayer2(BlockPos corePos, PoseStack poseStack, MultiBufferSource bufferSource, int packedLight, int packedOverlay) {&#10;        // Outer ring&#10;        for (int i = -3; i &lt;= 4; i++) {&#10;            renderHologramBlock(corePos.offset(i, 0, 4), poseStack, bufferSource, packedLight, packedOverlay);&#10;            renderHologramBlock(corePos.offset(-i, 0, -4), poseStack, bufferSource, packedLight, packedOverlay);&#10;            renderHologramBlock(corePos.offset(4, 0, -i), poseStack, bufferSource, packedLight, packedOverlay);&#10;            renderHologramBlock(corePos.offset(-4, 0, i), poseStack, bufferSource, packedLight, packedOverlay);&#10;        }&#10;        // Inner ring&#10;        for (int i = -1; i &lt;= 2; i++) {&#10;            renderHologramBlock(corePos.offset(i, 0, 2), poseStack, bufferSource, packedLight, packedOverlay);&#10;            renderHologramBlock(corePos.offset(-i, 0, -2), poseStack, bufferSource, packedLight, packedOverlay);&#10;            renderHologramBlock(corePos.offset(2, 0, -i), poseStack, bufferSource, packedLight, packedOverlay);&#10;            renderHologramBlock(corePos.offset(-2, 0, i), poseStack, bufferSource, packedLight, packedOverlay);&#10;        }&#10;        // Adjacent to core&#10;        renderHologramBlock(corePos.offset(1, 0, 0), poseStack, bufferSource, packedLight, packedOverlay);&#10;        renderHologramBlock(corePos.offset(-1, 0, 0), poseStack, bufferSource, packedLight, packedOverlay);&#10;        renderHologramBlock(corePos.offset(0, 0, -1), poseStack, bufferSource, packedLight, packedOverlay);&#10;        renderHologramBlock(corePos.offset(0, 0, 1), poseStack, bufferSource, packedLight, packedOverlay);&#10;    }&#10;&#10;    private void renderLayer3(BlockPos corePos, PoseStack poseStack, MultiBufferSource bufferSource, int packedLight, int packedOverlay) {&#10;        for (int i = -2; i &lt;= 3; i++) {&#10;            renderHologramBlock(corePos.offset(i, 1, 3), poseStack, bufferSource, packedLight, packedOverlay);&#10;            renderHologramBlock(corePos.offset(-i, 1, -3), poseStack, bufferSource, packedLight, packedOverlay);&#10;            renderHologramBlock(corePos.offset(3, 1, -i), poseStack, bufferSource, packedLight, packedOverlay);&#10;            renderHologramBlock(corePos.offset(-3, 1, i), poseStack, bufferSource, packedLight, packedOverlay);&#10;        }&#10;    }&#10;&#10;    private void renderHologramBlock(BlockPos pos, PoseStack poseStack, MultiBufferSource bufferSource, int packedLight, int packedOverlay) {&#10;        BlockPos corePos = pos.subtract(pos); // Relative to core&#10;        BlockState hologramState = CPABlocks.FUSION_REACTOR_CASING.get().defaultBlockState();&#10;        &#10;        poseStack.pushPose();&#10;        poseStack.translate(pos.getX(), pos.getY(), pos.getZ());&#10;        &#10;        VertexConsumer vertexConsumer = bufferSource.getBuffer(HologramRenderType.FUSION_CASING_HOLOGRAM);&#10;        &#10;        Minecraft.getInstance().getBlockRenderer().renderBatched(&#10;            hologramState,&#10;            pos,&#10;            blockEntity.getLevel(),&#10;            poseStack,&#10;            vertexConsumer,&#10;            false,&#10;            blockEntity.getLevel().getRandom(),&#10;            ModelData.EMPTY,&#10;            RenderType.translucent()&#10;        );&#10;        &#10;        poseStack.popPose();&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/de/wutzuket/create_overdrive/client/render/HologramRenderType.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/de/wutzuket/create_overdrive/client/render/HologramRenderType.java" />
              <option name="originalContent" value="package de.wutzuket.create_overdrive.client.render;&#10;&#10;import com.mojang.blaze3d.vertex.DefaultVertexFormat;&#10;import com.mojang.blaze3d.vertex.VertexFormat;&#10;import net.minecraft.client.renderer.RenderStateShard;&#10;import net.minecraft.client.renderer.RenderType;&#10;import net.minecraft.resources.ResourceLocation;&#10;&#10;public class HologramRenderType extends RenderType {&#10;&#10;    public HologramRenderType(String name, VertexFormat format, VertexFormat.Mode mode, int bufferSize, boolean affectsCrumbling, boolean sortOnUpload, Runnable setupState, Runnable clearState) {&#10;        super(name, format, mode, bufferSize, affectsCrumbling, sortOnUpload, setupState, clearState);&#10;    }&#10;&#10;    public static final RenderType HOLOGRAM = RenderType.create(&#10;        &quot;hologram&quot;,&#10;        DefaultVertexFormat.BLOCK,&#10;        VertexFormat.Mode.QUADS,&#10;        2097152,&#10;        true,&#10;        true,&#10;        RenderType.CompositeState.builder()&#10;            .setShaderState(RenderStateShard.RENDERTYPE_TRANSLUCENT_SHADER)&#10;            .setTransparencyState(RenderStateShard.TRANSLUCENT_TRANSPARENCY)&#10;            .setTextureState(RenderStateShard.BLOCK_SHEET)&#10;            .setCullState(RenderStateShard.NO_CULL)&#10;            .setWriteMaskState(RenderStateShard.COLOR_WRITE)&#10;            .setLightmapState(RenderStateShard.LIGHTMAP)&#10;            .setOverlayState(RenderStateShard.OVERLAY)&#10;            .createCompositeState(false)&#10;    );&#10;}&#10;" />
              <option name="updatedContent" value="package de.wutzuket.create_overdrive.client.render;&#10;&#10;import com.mojang.blaze3d.vertex.DefaultVertexFormat;&#10;import com.mojang.blaze3d.vertex.VertexFormat;&#10;import net.minecraft.client.renderer.RenderStateShard;&#10;import net.minecraft.client.renderer.RenderType;&#10;&#10;public class HologramRenderType extends RenderType {&#10;&#10;    public HologramRenderType(String name, VertexFormat format, VertexFormat.Mode mode, int bufferSize, boolean affectsCrumbling, boolean sortOnUpload, Runnable setupState, Runnable clearState) {&#10;        super(name, format, mode, bufferSize, affectsCrumbling, sortOnUpload, setupState, clearState);&#10;    }&#10;&#10;    public static final RenderType HOLOGRAM = RenderType.create(&#10;        &quot;hologram&quot;,&#10;        DefaultVertexFormat.BLOCK,&#10;        VertexFormat.Mode.QUADS,&#10;        2097152,&#10;        true,&#10;        true,&#10;        RenderType.CompositeState.builder()&#10;            .setShaderState(RenderStateShard.RENDERTYPE_TRANSLUCENT_SHADER)&#10;            .setTransparencyState(RenderStateShard.TRANSLUCENT_TRANSPARENCY)&#10;            .setTextureState(RenderStateShard.BLOCK_SHEET)&#10;            .setCullState(RenderStateShard.NO_CULL)&#10;            .setWriteMaskState(RenderStateShard.COLOR_WRITE)&#10;            .setLightmapState(RenderStateShard.LIGHTMAP)&#10;            .setOverlayState(RenderStateShard.OVERLAY)&#10;            .createCompositeState(false)&#10;    );&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/de/wutzuket/create_overdrive/events/ClientEvents.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/de/wutzuket/create_overdrive/events/ClientEvents.java" />
              <option name="updatedContent" value="package de.wutzuket.create_overdrive.events;&#10;&#10;import de.wutzuket.create_overdrive.Main;&#10;import de.wutzuket.create_overdrive.blocks.fusion_reactor.connected_textures.CTModelLoader;&#10;import net.neoforged.api.distmarker.Dist;&#10;import net.neoforged.bus.api.SubscribeEvent;&#10;import net.neoforged.fml.common.Mod;&#10;import net.neoforged.neoforge.client.event.ModelEvent;&#10;import net.neoforged.neoforge.client.event.TextureStitchEvent;&#10;&#10;@Mod.EventBusSubscriber(modid = Main.MODID, bus = Mod.EventBusSubscriber.Bus.MOD, value = Dist.CLIENT)&#10;public class ClientEvents {&#10;    &#10;    @SubscribeEvent&#10;    public static void onModelBake(ModelEvent.ModifyBakingResult event) {&#10;        CTModelLoader.onModelBakeEvent(event);&#10;    }&#10;    &#10;    @SubscribeEvent&#10;    public static void onTextureStitch(TextureStitchEvent.Pre event) {&#10;        CTModelLoader.onTextureStitch(event);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>